# Quick start guide for `poly-scribe`

Let us walk through a simple example of how to use `poly-scribe` environment to handle a polymorphic data structure in C++ and Python.
For this example we will consider a configuration structure for a plugin system where each plugin can have different parameters and the type of the plugin is determined from the configuration.

## Step 1: Define the WebIDL

First, we need to define the WebIDL for our configuration structure.

``` webidl
--8<-- "docs/assets/plugin.webidl"
```

1. This defines a fixed-size sequence of doubles.
   The extra attribute `Size=3` indicates that the sequence will always have exactly three elements.
2. This is an enumeration with two possible values.
3. This is the base data structure for all plugins.
4. `name` and `description` are required fields for the base plugin configuration, these must be provided for all plugins.
5. `paramA` is an optional parameter with a default value of `42`.
6. If not specified via the `required` attribute, the parameter is optional.
7. This maps a string to a base plugin configuration, allowing for polymorphic data structures.

## Step 2: Generate the Code

For a C++ project, the easiest way to generate the code is to use the CMake function provided by `poly-scribe`.
It is recommended to use add `poly_scribe` either as a submodule or via fetch content in your project.
In your `CMakeLists.txt`, you can then add the following lines:

```cmake
add_library (plugin_data INTERFACE)

generate_data_structures (
	plugin_data
	IDL_FILE plugin.webidl
	OUTPUT_CPP "plugin_data.hpp"
	AUTHOR_NAME "Max Mustermann"
	AUTHOR_MAIL "dummy@mail.com"
	NAMESPACE "plugin_namespace"
	LICENCE "MIT"
	OUTPUT_HEADER_DIR plugin_data_dir
	OUTPUT_PYTHON_PKG plugin_data
	OUTPUT_PYTHON_PKG_VAR PYTHON_PKG_GENERATED
	OUTPUT_SCHEMA plugin_schema.json
	OUTPUT_SCHEMA_VAR SCHEMA_GENERATED
	OUTPUT_SCHEMA_CLASS PluginSystem
)
```

This will generate three things:

- `plugin_data_dir/plugin_data.hpp`: The C++ header file with the generated code.
- A Python package `plugin_data` with the generated code.
- `plugin_schema.json`: The JSON schema for the data structure.

The two variables `PYTHON_PKG_GENERATED` and `SCHEMA_GENERATED` will contain the paths to the generated Python package and JSON schema respectively.
The C++ code will automatically be linked to the supplied target `plugin_data`.

??? note "Generated code"
    === "`plugin_data.hpp`"

        ``` c++
        --8<-- "docs/assets/plugin_data.hpp"
        ```

    === "`plugin_data.py`"

        ``` python
        --8<-- "docs/assets/plugin_data.py"
        ```

    === "`plugin_schema.hpp`"

        ``` json
        --8<-- "docs/assets/plugin_schema.json"
        ```

## Step 3: Use the Generated Code

Now that we have the generated code, we can use it in our C++ and Python projects.
For example, we can use python to script the generation of the configuration file and then load it in C++.

```python
--8<-- "docs/assets/example.py"
```

``` cpp
--8<-- "docs/assets/example.cpp"
```

When running the C++ application, it will read the configuration file generated by the Python script and print the plugin information.

```bash
$ python example.py
$ cat example.json
--8<-- "docs/assets/example.json"
$ ./example example.json
Plugin Key: plugin1
Type: PluginA
Name: Plugin A
Description: This is Plugin A
Param A: 42
Param Vector: 1 2 3
Plugin Key: plugin2
Type: PluginB
Name: Plugin B
Description: This is Plugin B
Param B: 3.14
Param Enum: 0
```