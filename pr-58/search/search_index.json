{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>poly-scribe</code>","text":"<p><code>poly-scribe</code> is a software environment designed to facilitate easy (polymorphic) data structure serialization, deserialization and exchange between different programming languages. The intend is to provide a type-safe and similar interface across multiple languages, allowing developers to work with data structures without worrying about the underlying serialization format. This is achieved by generating code based on a common interface definition. For this purpose, <code>poly-scribe</code> uses WebIDL (Web Interface Definition Language) to define the data structures. The generated code can then be used in various programming languages such as C++ or Python. As such, a simple call to a <code>load</code> and <code>save</code> function will serialize and deserialize the data structure to and from a file respectively.</p> <p>To simplify the process of generating code, <code>poly-scribe</code> provides a python package called <code>poly_scribe_code_gen</code> as well as a CMake function to generate code for a C++ project.</p> <p>For more information on how to write WebIDL definitions and what the generated code looks like, please refer to the Quick Start Guide. For more detailed information on the code generation process, please refer to the Code Generation API.</p>"},{"location":"#implementation","title":"Implementation","text":""},{"location":"#c","title":"C++","text":"<p>For C++ the generated code uses a thin wrapper library around the <code>reflect-cpp</code> library.</p>"},{"location":"#python","title":"Python","text":"<p>For Python the generated code uses the <code>pydantic</code> library to provide a type-safe interface for the data structures.</p>"},{"location":"additional/","title":"Additional features","text":""},{"location":"additional/#default-values","title":"Default values","text":"<p>Sometimes, you may want to provide default values for user defined types. This can be achieved by setting the default value in the IDL to <code>{}</code>, like in this example:</p> <pre><code>dictionary SubConfig\n{\n    int answer = 42;\n};\n\ndictionary Config\n{\n    SubConfig sub = {};\n};\n</code></pre> <p>This will create a new instance of <code>SubConfig</code> in <code>Config</code>. Note, that this is only really possible if <code>SubConfig</code> has no required fields.</p> <p>As an extension to this, this approach can also be used with polymorphic types. Here, there might not be a single concrete type to instantiate, but rather a family of types that share a common base. In this case you can define the desired default type in the IDL via the extra attribute <code>Default</code> like so:</p> <pre><code>dictionary Base\n{};\n\ndictionary A : Base\n{};\n\ndictionary B : Base\n{};\n\ndictionary Container\n{\n    [Default=A] Base sub = {};\n}\n</code></pre>"},{"location":"quick_start/","title":"Quick start guide for <code>poly-scribe</code>","text":"<p>Let us walk through a simple example of how to use <code>poly-scribe</code> environment to handle a polymorphic data structure in C++ and Python. For this example we will consider a configuration structure for a plugin system where each plugin can have different parameters and the type of the plugin is determined from the configuration.</p>"},{"location":"quick_start/#step-1-define-the-webidl","title":"Step 1: Define the WebIDL","text":"<p>First, we need to define the WebIDL for our configuration structure.</p> <pre><code>typedef [Size=3] sequence&lt;double&gt; Vector; // (1)\n\nenum Enumeration { // (2)\n    \"value1\",\n    \"value2\"\n};\n\ndictionary PluginBase // (3)\n{\n    required string name; // (4)\n    required string description;\n};\n\ndictionary PluginA : PluginBase\n{\n    int paramA = 42; // (5)\n    Vector paramVector; // (6)\n};\n\ndictionary PluginB : PluginBase\n{\n    float paramB;\n    Enumeration paramEnum;\n};\n\ndictionary PluginSystem\n{\n    record&lt;ByteString, PluginBase&gt; plugin_map; // (7)\n};\n</code></pre> <ol> <li>This defines a fixed-size sequence of doubles.    The extra attribute <code>Size=3</code> indicates that the sequence will always have exactly three elements.</li> <li>This is an enumeration with two possible values.</li> <li>This is the base data structure for all plugins.</li> <li><code>name</code> and <code>description</code> are required fields for the base plugin configuration, these must be provided for all plugins.</li> <li><code>paramA</code> is an optional parameter with a default value of <code>42</code>.</li> <li>If not specified via the <code>required</code> attribute, the parameter is optional.</li> <li>This maps a string to a base plugin configuration, allowing for polymorphic data structures.</li> </ol>"},{"location":"quick_start/#step-2-generate-the-code","title":"Step 2: Generate the Code","text":"<p>For a C++ project, the easiest way to generate the code is to use the CMake function provided by <code>poly-scribe</code>. It is recommended to use add <code>poly_scribe</code> either as a submodule or via fetch content in your project. In your <code>CMakeLists.txt</code>, you can then add the following lines:</p> <pre><code>add_library (plugin_data INTERFACE)\n\ngenerate_data_structures (\n    plugin_data\n    IDL_FILE plugin.webidl\n    OUTPUT_CPP \"plugin_data.hpp\"\n    AUTHOR_NAME \"Max Mustermann\"\n    AUTHOR_MAIL \"dummy@mail.com\"\n    NAMESPACE \"plugin_namespace\"\n    LICENCE \"MIT\"\n    OUTPUT_HEADER_DIR plugin_data_dir\n    OUTPUT_PYTHON_PKG plugin_data\n    OUTPUT_PYTHON_PKG_VAR PYTHON_PKG_GENERATED\n    OUTPUT_SCHEMA plugin_schema.json\n    OUTPUT_SCHEMA_VAR SCHEMA_GENERATED\n    OUTPUT_SCHEMA_CLASS PluginSystem\n)\n</code></pre> <p>This will generate three things:</p> <ul> <li><code>plugin_data_dir/plugin_data.hpp</code>: The C++ header file with the generated code.</li> <li>A Python package <code>plugin_data</code> with the generated code.</li> <li><code>plugin_schema.json</code>: The JSON schema for the data structure.</li> </ul> <p>The two variables <code>PYTHON_PKG_GENERATED</code> and <code>SCHEMA_GENERATED</code> will contain the paths to the generated Python package and JSON schema respectively. The C++ code will automatically be linked to the supplied target <code>plugin_data</code>.</p> Generated code <code>plugin_data.hpp</code><code>plugin_data.py</code><code>plugin_schema.hpp</code> <pre><code>/**\n * \\file plugin_data.hpp\n * \\brief Automatically generated using poly-scribe-code-gen.\n * \\author Max Mustermann dummy@mail.com\n * \\copyright\n * Copyright (c) 2025-present Max Mustermann\n * Distributed under the MIT licence.\n */\n\n#pragma once\n\n#include &lt;poly-scribe/poly-scribe.hpp&gt;\n\n// NOLINTBEGIN\n\nnamespace plugin_namespace {\n\n    // Forward declarations\n    struct PluginBase;\n    struct PluginA;\n    struct PluginB;\n    struct PluginSystem;\n\n    enum class Enumeration {\n        value1,\n        value2\n    };\n\n    using Vector = std::array&lt;double, 3&gt;;\n\n    using PluginBase_t = rfl::TaggedUnion&lt;\"type\", PluginBase, PluginA, PluginB&gt;;\n\n    struct PluginBase {\n        std::string name;\n        std::string description;\n    };\n\n    struct PluginA {\n        // Inherited from PluginBase\n        std::optional&lt;int&gt; paramA = 42;\n        std::optional&lt;Vector&gt; paramVector;\n        std::string name;\n        std::string description;\n    };\n\n    struct PluginB {\n        // Inherited from PluginBase\n        std::optional&lt;float&gt; paramB;\n        std::optional&lt;Enumeration&gt; paramEnum;\n        std::string name;\n        std::string description;\n    };\n\n    struct PluginSystem {\n        std::optional&lt;std::unordered_map&lt;std::string, PluginBase_t&gt;&gt; plugin_map;\n    };\n\n}  // namespace plugin_namespace\n\n// NOLINTEND\n</code></pre> <pre><code>from pathlib import Path\nfrom typing import (Annotated, Any, Dict, List, Literal, Optional, Tuple, Type,\n                    TypeVar, Union)\n\nimport cbor2\nfrom annotated_types import Len\nfrom pydantic import BaseModel, Field\nfrom pydantic_yaml import parse_yaml_file_as, to_yaml_file\nfrom strenum import StrEnum\n\nT = TypeVar(\"T\", bound=BaseModel)\n\n\nVector = Annotated[List[float], Len(min_length=3, max_length=3)]\n\n\nclass Enumeration(StrEnum):\n    value1 = \"value1\"\n    value2 = \"value2\"\n\n\nclass PluginBase(BaseModel):\n    name: str\n    description: str\n    type: Literal[\"PluginBase\"] = \"PluginBase\"\n\n\nclass PluginA(PluginBase):\n    paramA: Optional[int] = 42\n    paramVector: Optional[Vector] = None\n    type: Literal[\"PluginA\"] = \"PluginA\"\n\n\nclass PluginB(PluginBase):\n    paramB: Optional[float] = None\n    paramEnum: Optional[Enumeration] = None\n    type: Literal[\"PluginB\"] = \"PluginB\"\n\n\nclass PluginSystem(BaseModel):\n    plugin_map: Optional[\n        Dict[\n            str,\n            Annotated[Union[PluginA, PluginB, PluginBase], Field(discriminator=\"type\")],\n        ]\n    ] = None\n\n\ndef load(model_type: Type[T], file: Union[Path, str]) -&gt; T:\n    if isinstance(file, str):\n        file = Path(file).resolve()\n    elif isinstance(file, Path):\n        file = file.resolve()\n    else:\n        msg = f\"Expected Path or str, but got {file!r}\"\n        raise TypeError(msg)\n\n    if not file.exists():\n        msg = f\"File {file} does not exist\"\n        raise FileNotFoundError(msg)\n\n    if file.suffix == \".yaml\":\n        return parse_yaml_file_as(model_type, file)\n    elif file.suffix == \".json\":\n        json_string = file.read_text()\n        return model_type.model_validate_json(json_string)\n    elif file.suffix == \".cbor\":\n        with file.open(\"rb\") as f:\n            data = cbor2.load(f)\n        return model_type.model_validate(data)\n    else:\n        raise ValueError(f\"Unsupported file extension {file.suffix}\")\n\n\ndef save(file: Union[Path, str], model: Union[BaseModel]):\n    if isinstance(file, str):  # local path to file\n        file = Path(file).resolve()\n    elif isinstance(file, Path):\n        file = file.resolve()\n    else:\n        raise TypeError(f\"Expected Path, str, or stream, but got {file!r}\")\n\n    if file.suffix == \".yaml\":\n        to_yaml_file(file, model)\n    elif file.suffix == \".json\":\n        json_string = model.model_dump_json(indent=4)\n        file.write_text(json_string)\n    elif file.suffix == \".cbor\":\n        with file.open(\"wb\") as f:\n            cbor2.dump(model.model_dump(), f)\n    else:\n        raise ValueError(f\"Unsupported file extension {file.suffix}\")\n</code></pre> <pre><code>{\n  \"$defs\": {\n    \"Enumeration\": {\n      \"enum\": [\n        \"value1\",\n        \"value2\"\n      ],\n      \"title\": \"Enumeration\",\n      \"type\": \"string\"\n    },\n    \"PluginA\": {\n      \"properties\": {\n        \"name\": {\n          \"title\": \"Name\",\n          \"type\": \"string\"\n        },\n        \"description\": {\n          \"title\": \"Description\",\n          \"type\": \"string\"\n        },\n        \"type\": {\n          \"const\": \"PluginA\",\n          \"default\": \"PluginA\",\n          \"title\": \"Type\",\n          \"type\": \"string\"\n        },\n        \"paramA\": {\n          \"anyOf\": [\n            {\n              \"type\": \"integer\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": 42,\n          \"title\": \"Parama\"\n        },\n        \"paramVector\": {\n          \"anyOf\": [\n            {\n              \"items\": {\n                \"type\": \"number\"\n              },\n              \"maxItems\": 3,\n              \"minItems\": 3,\n              \"type\": \"array\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"title\": \"Paramvector\"\n        }\n      },\n      \"required\": [\n        \"name\",\n        \"description\"\n      ],\n      \"title\": \"PluginA\",\n      \"type\": \"object\"\n    },\n    \"PluginB\": {\n      \"properties\": {\n        \"name\": {\n          \"title\": \"Name\",\n          \"type\": \"string\"\n        },\n        \"description\": {\n          \"title\": \"Description\",\n          \"type\": \"string\"\n        },\n        \"type\": {\n          \"const\": \"PluginB\",\n          \"default\": \"PluginB\",\n          \"title\": \"Type\",\n          \"type\": \"string\"\n        },\n        \"paramB\": {\n          \"anyOf\": [\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"title\": \"Paramb\"\n        },\n        \"paramEnum\": {\n          \"anyOf\": [\n            {\n              \"$ref\": \"#/$defs/Enumeration\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null\n        }\n      },\n      \"required\": [\n        \"name\",\n        \"description\"\n      ],\n      \"title\": \"PluginB\",\n      \"type\": \"object\"\n    },\n    \"PluginBase\": {\n      \"properties\": {\n        \"name\": {\n          \"title\": \"Name\",\n          \"type\": \"string\"\n        },\n        \"description\": {\n          \"title\": \"Description\",\n          \"type\": \"string\"\n        },\n        \"type\": {\n          \"const\": \"PluginBase\",\n          \"default\": \"PluginBase\",\n          \"title\": \"Type\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"name\",\n        \"description\"\n      ],\n      \"title\": \"PluginBase\",\n      \"type\": \"object\"\n    }\n  },\n  \"properties\": {\n    \"plugin_map\": {\n      \"anyOf\": [\n        {\n          \"additionalProperties\": {\n            \"discriminator\": {\n              \"mapping\": {\n                \"PluginA\": \"#/$defs/PluginA\",\n                \"PluginB\": \"#/$defs/PluginB\",\n                \"PluginBase\": \"#/$defs/PluginBase\"\n              },\n              \"propertyName\": \"type\"\n            },\n            \"oneOf\": [\n              {\n                \"$ref\": \"#/$defs/PluginA\"\n              },\n              {\n                \"$ref\": \"#/$defs/PluginB\"\n              },\n              {\n                \"$ref\": \"#/$defs/PluginBase\"\n              }\n            ]\n          },\n          \"type\": \"object\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"title\": \"Plugin Map\"\n    }\n  },\n  \"title\": \"PluginSystem\",\n  \"type\": \"object\"\n}\n</code></pre>"},{"location":"quick_start/#step-3-use-the-generated-code","title":"Step 3: Use the Generated Code","text":"<p>Now that we have the generated code, we can use it in our C++ and Python projects. For example, we can use python to script the generation of the configuration file and then load it in C++.</p> <pre><code>import plugin_data as pd\n\npd_system = pd.PluginSystem(\n    plugin_map={\n        \"plugin1\": pd.PluginA(\n            name=\"Plugin A\",\n            description=\"This is Plugin A\",\n            paramVector=[1.0, 2.0, 3.0],\n        ),\n        \"plugin2\": pd.PluginB(\n            name=\"Plugin B\",\n            description=\"This is Plugin B\",\n            paramB=3.14,\n            paramEnum=pd.Enumeration.value1,\n        ),\n    }\n)\n\npd.save(\"example.json\", pd_system)\n</code></pre> <pre><code>#include \"plugin_data.hpp\"\n\n// This is required so that gcc compiles the code correctly.\ntemplate&lt;typename T&gt;\n[[noreturn]] void unknown_plugin_type_static_assert( )\n{\n    static_assert( sizeof( T ) == 0, \"Unknown plugin type\" );\n}\n\nint main( int argc, char** argv )\n{\n    if( argc &lt; 2 )\n    {\n        std::cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" &lt;input_file&gt;\" &lt;&lt; std::endl;\n        return 1;\n    }\n\n    std::filesystem::path input_file = argv[1];\n\n    auto result = poly_scribe::load&lt;plugin_namespace::PluginSystem&gt;( input_file );\n    if( !result )\n    {\n        std::cerr &lt;&lt; \"Error loading file: \" &lt;&lt; result.error( ).what( ) &lt;&lt; std::endl;\n        return 1;\n    }\n\n    plugin_namespace::PluginSystem&amp; plugin_system = result.value( );\n\n    if( plugin_system.plugin_map )\n    {\n        for( const auto&amp; [name, plugin]: *plugin_system.plugin_map )\n        {\n            std::cout &lt;&lt; \"Plugin Key: \" &lt;&lt; name &lt;&lt; std::endl;\n\n            auto visitor = []( const auto&amp; plugin )\n            {\n                using Type = std::decay_t&lt;decltype( plugin )&gt;;\n\n                if constexpr( std::is_same_v&lt;Type, plugin_namespace::PluginA&gt; )\n                {\n                    std::cout &lt;&lt; \"Type: PluginA\" &lt;&lt; std::endl;\n                    std::cout &lt;&lt; \"Name: \" &lt;&lt; plugin.name &lt;&lt; std::endl;\n                    std::cout &lt;&lt; \"Description: \" &lt;&lt; plugin.description &lt;&lt; std::endl;\n                    std::cout &lt;&lt; \"Param A: \" &lt;&lt; plugin.paramA.value_or( 0 ) &lt;&lt; std::endl;\n                    if( plugin.paramVector )\n                    {\n                        std::cout &lt;&lt; \"Param Vector: \";\n                        for( const auto&amp; v: *plugin.paramVector )\n                        {\n                            std::cout &lt;&lt; v &lt;&lt; \" \";\n                        }\n                        std::cout &lt;&lt; std::endl;\n                    }\n                }\n                else if constexpr( std::is_same_v&lt;Type, plugin_namespace::PluginB&gt; )\n                {\n                    std::cout &lt;&lt; \"Type: PluginB\" &lt;&lt; std::endl;\n                    std::cout &lt;&lt; \"Name: \" &lt;&lt; plugin.name &lt;&lt; std::endl;\n                    std::cout &lt;&lt; \"Description: \" &lt;&lt; plugin.description &lt;&lt; std::endl;\n                    std::cout &lt;&lt; \"Param B: \" &lt;&lt; plugin.paramB.value_or( 0.0f ) &lt;&lt; std::endl;\n                    if( plugin.paramEnum )\n                    {\n                        std::cout &lt;&lt; \"Param Enum: \" &lt;&lt; static_cast&lt;int&gt;( *plugin.paramEnum ) &lt;&lt; std::endl;\n                    }\n                }\n                else if constexpr( std::is_same_v&lt;Type, plugin_namespace::PluginBase&gt; )\n                {\n                    std::cout &lt;&lt; \"Type: PluginBase\" &lt;&lt; std::endl;\n                    std::cout &lt;&lt; \"Name: \" &lt;&lt; plugin.name &lt;&lt; std::endl;\n                    std::cout &lt;&lt; \"Description: \" &lt;&lt; plugin.description &lt;&lt; std::endl;\n                }\n                else\n                {\n                    unknown_plugin_type_static_assert&lt;Type&gt;( );\n                }\n            };\n\n            plugin.visit( visitor );\n        }\n    }\n    else\n    {\n        std::cout &lt;&lt; \"No plugins loaded.\" &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre> <p>When running the C++ application, it will read the configuration file generated by the Python script and print the plugin information.</p> <pre><code>$ python example.py\n$ cat example.json\n{\n    \"plugin_map\": {\n        \"plugin1\": {\n            \"name\": \"Plugin A\",\n            \"description\": \"This is Plugin A\",\n            \"type\": \"PluginA\",\n            \"paramA\": 42,\n            \"paramVector\": [\n                1.0,\n                2.0,\n                3.0\n            ]\n        },\n        \"plugin2\": {\n            \"name\": \"Plugin B\",\n            \"description\": \"This is Plugin B\",\n            \"type\": \"PluginB\",\n            \"paramB\": 3.14,\n            \"paramEnum\": \"value1\"\n        }\n    }\n}\n$ ./example example.json\nPlugin Key: plugin1\nType: PluginA\nName: Plugin A\nDescription: This is Plugin A\nParam A: 42\nParam Vector: 1 2 3\nPlugin Key: plugin2\nType: PluginB\nName: Plugin B\nDescription: This is Plugin B\nParam B: 3.14\nParam Enum: 0\n</code></pre>"},{"location":"reference/","title":"Code Generation API","text":"<p>Under this section, you will find the documentation for the Code Generation API. This API allows you to generate code snippets based on WebIDL definitions.</p> <p>Take a look at the main module of the code generation.</p>"},{"location":"reference/poly_scribe_code_gen/","title":"poly_scribe_code_gen","text":""},{"location":"reference/poly_scribe_code_gen/#poly_scribe_code_gen","title":"poly_scribe_code_gen","text":"<p>Modules:</p> <ul> <li> <code>cli</code>           \u2013            <p>Command line interface for the poly_scribe_code_gen package.</p> </li> <li> <code>cpp_gen</code>           \u2013            <p>This module generates C++ code from parsed IDL data.</p> </li> <li> <code>parse_idl</code>           \u2013            <p>Parse WebIDL files and extract relevant information.</p> </li> <li> <code>py_gen</code>           \u2013            <p>Generate Python code from parsed IDL data.</p> </li> </ul>"},{"location":"reference/poly_scribe_code_gen/_types/","title":"poly_scribe_code_gen._types","text":""},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types","title":"_types","text":"<p>Types for poly-scribe code generation.</p> <p>This module defines the types used in the poly-scribe code generation process.</p> <p>Classes:</p> <ul> <li> <code>AdditionalData</code>           \u2013            <p>Additional data for the code generation.</p> </li> <li> <code>ParsedIDL</code>           \u2013            <p>Parsed IDL data.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>cpp_types</code>           \u2013            <p>All types for poly-scribe.</p> </li> <li> <code>floating_point_types</code>           \u2013            <p>Floating point types for poly-scribe.</p> </li> <li> <code>integer_types</code>           \u2013            <p>Integer types for poly-scribe.</p> </li> <li> <code>std_types</code>           \u2013            <p>String types for poly-scribe.</p> </li> </ul>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.cpp_types","title":"cpp_types  <code>module-attribute</code>","text":"<pre><code>cpp_types = integer_types + floating_point_types + std_types\n</code></pre> <p>All types for poly-scribe.</p> <p>These are espcially useful for the C++ code generation.</p>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.floating_point_types","title":"floating_point_types  <code>module-attribute</code>","text":"<pre><code>floating_point_types = ['float', 'double', 'long double']\n</code></pre> <p>Floating point types for poly-scribe.</p>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.integer_types","title":"integer_types  <code>module-attribute</code>","text":"<pre><code>integer_types = [\n    \"bool\",\n    \"char\",\n    \"unsigned char\",\n    \"short\",\n    \"unsigned short\",\n    \"int\",\n    \"unsigned int\",\n    \"long\",\n    \"unsigned long\",\n    \"long long\",\n    \"unsigned long long\",\n]\n</code></pre> <p>Integer types for poly-scribe.</p>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.std_types","title":"std_types  <code>module-attribute</code>","text":"<pre><code>std_types = ['ByteString', 'string']\n</code></pre> <p>String types for poly-scribe.</p>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.AdditionalData","title":"AdditionalData","text":"<p>               Bases: <code>TypedDict</code></p> <p>Additional data for the code generation.</p> <p>This is used to pass additional data to the code generation process.</p> <p>Attributes:</p> <ul> <li> <code>author_email</code>               (<code>NotRequired[str]</code>)           \u2013            <p>Author email for the generated code.</p> </li> <li> <code>author_name</code>               (<code>NotRequired[str]</code>)           \u2013            <p>Author name for the generated code.</p> </li> <li> <code>licence</code>               (<code>NotRequired[str]</code>)           \u2013            <p>Licence for the generated code.</p> </li> <li> <code>out_file</code>               (<code>NotRequired[Optional[str]]</code>)           \u2013            <p>Output file for the generated code.</p> </li> <li> <code>package</code>               (<code>str</code>)           \u2013            <p>Package name for the generated code.</p> </li> <li> <code>year</code>               (<code>NotRequired[str]</code>)           \u2013            <p>Year for the generated code for copyright.</p> </li> </ul>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.AdditionalData.author_email","title":"author_email  <code>instance-attribute</code>","text":"<pre><code>author_email: NotRequired[str]\n</code></pre> <p>Author email for the generated code.</p>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.AdditionalData.author_name","title":"author_name  <code>instance-attribute</code>","text":"<pre><code>author_name: NotRequired[str]\n</code></pre> <p>Author name for the generated code.</p>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.AdditionalData.licence","title":"licence  <code>instance-attribute</code>","text":"<pre><code>licence: NotRequired[str]\n</code></pre> <p>Licence for the generated code.</p>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.AdditionalData.out_file","title":"out_file  <code>instance-attribute</code>","text":"<pre><code>out_file: NotRequired[Optional[str]]\n</code></pre> <p>Output file for the generated code.</p>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.AdditionalData.package","title":"package  <code>instance-attribute</code>","text":"<pre><code>package: str\n</code></pre> <p>Package name for the generated code.</p>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.AdditionalData.year","title":"year  <code>instance-attribute</code>","text":"<pre><code>year: NotRequired[str]\n</code></pre> <p>Year for the generated code for copyright.</p>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.ParsedIDL","title":"ParsedIDL","text":"<p>               Bases: <code>TypedDict</code></p> <p>Parsed IDL data.</p> <p>Attributes:</p> <ul> <li> <code>enums</code>               (<code>dict[str, dict[str, Any]]</code>)           \u2013            <p>Enums in the IDL.</p> </li> <li> <code>inheritance_data</code>               (<code>dict[str, list[str]]</code>)           \u2013            <p>Inheritance data of the contained structs.</p> </li> <li> <code>structs</code>               (<code>dict[str, dict[str, Any]]</code>)           \u2013            <p>Structs in the IDL.</p> </li> <li> <code>typedefs</code>               (<code>dict[str, dict[str, Any]]</code>)           \u2013            <p>Typedefs in the IDL.</p> </li> </ul>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.ParsedIDL.enums","title":"enums  <code>instance-attribute</code>","text":"<pre><code>enums: dict[str, dict[str, Any]]\n</code></pre> <p>Enums in the IDL.</p>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.ParsedIDL.inheritance_data","title":"inheritance_data  <code>instance-attribute</code>","text":"<pre><code>inheritance_data: dict[str, list[str]]\n</code></pre> <p>Inheritance data of the contained structs.</p>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.ParsedIDL.structs","title":"structs  <code>instance-attribute</code>","text":"<pre><code>structs: dict[str, dict[str, Any]]\n</code></pre> <p>Structs in the IDL.</p>"},{"location":"reference/poly_scribe_code_gen/_types/#poly_scribe_code_gen._types.ParsedIDL.typedefs","title":"typedefs  <code>instance-attribute</code>","text":"<pre><code>typedefs: dict[str, dict[str, Any]]\n</code></pre> <p>Typedefs in the IDL.</p>"},{"location":"reference/poly_scribe_code_gen/cli/","title":"poly_scribe_code_gen.cli","text":""},{"location":"reference/poly_scribe_code_gen/cli/#poly_scribe_code_gen.cli","title":"cli","text":"<p>Command line interface for the poly_scribe_code_gen package.</p> <p>This module provides the command line interface for generating code from WebIDL files.</p> <p>Functions:</p> <ul> <li> <code>poly_scribe_code_gen</code>             \u2013              <p>Main entry point for the poly_scribe_code_gen command line interface.</p> </li> </ul>"},{"location":"reference/poly_scribe_code_gen/cli/#poly_scribe_code_gen.cli.poly_scribe_code_gen","title":"poly_scribe_code_gen","text":"<pre><code>poly_scribe_code_gen() -&gt; int\n</code></pre> <p>Main entry point for the poly_scribe_code_gen command line interface.</p> <p>This function parses command line arguments, processes the input WebIDL file, and generates the requested code files. It supports generating C++, Python, and JSON schema files based on the provided WebIDL. It also allows for additional data to be passed for code generation.</p> <p>If the <code>--schema</code> option is used, it requires either the <code>--py</code> or <code>--py-package</code> option to be specified, as the schema generation relies on the Python code being generated.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Exit code, 0 for success, non-zero for failure.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If there is an error in the command line arguments or during code generation.</p> </li> </ul>"},{"location":"reference/poly_scribe_code_gen/cpp_gen/","title":"poly_scribe_code_gen.cpp_gen","text":""},{"location":"reference/poly_scribe_code_gen/cpp_gen/#poly_scribe_code_gen.cpp_gen","title":"cpp_gen","text":"<p>This module generates C++ code from parsed IDL data.</p> <p>It uses Jinja2 templates to render the C++ code based on the parsed IDL data and additional data provided. It supports generating enumerations, typedefs, structs, and polymorphic structs as tagged unions.</p> <p>Functions:</p> <ul> <li> <code>generate_cpp</code>             \u2013              <p>Generate C++ code from the parsed IDL data.</p> </li> </ul>"},{"location":"reference/poly_scribe_code_gen/cpp_gen/#poly_scribe_code_gen.cpp_gen.generate_cpp","title":"generate_cpp","text":"<pre><code>generate_cpp(\n    parsed_idl: ParsedIDL,\n    additional_data: AdditionalData,\n    out_file: Path,\n) -&gt; None\n</code></pre> <p>Generate C++ code from the parsed IDL data.</p> <p>Based on the parsed IDL data and additional data, this function generates reflect-cpp data structures. The generated code is written to the specified output file.</p> <p>Enumerations are generated as <code>enum class</code> types, and typedefs are implemented via <code>using</code> statements. Structs are generated as C++ structs, and the inheritance is flattened as this is not supported by reflect-cpp. Polymorphic structs are generated as tagged unions.</p> <p>All code is contained in a namespace, the name of which is specified via the <code>package</code> key in the additional data.</p> <p>The generated header file contains will also include the <code>poly-scribe.hpp</code> header file. In this header file, two convenience functions are defined: <code>load</code> and <code>save</code>, which can be used to load and save the generated structs. These functions will, depending on the type of file store the data in different formats. The following formats are supported:</p> <ul> <li>JSON</li> <li>YAML</li> <li>CBOR</li> <li>UBJSON</li> </ul> <p>Any types from the IDL that are not supported in C++ are converted to cpp types.</p>"},{"location":"reference/poly_scribe_code_gen/parse_idl/","title":"poly_scribe_code_gen.parse_idl","text":""},{"location":"reference/poly_scribe_code_gen/parse_idl/#poly_scribe_code_gen.parse_idl","title":"parse_idl","text":"<p>Parse WebIDL files and extract relevant information.</p> <p>This module provides functionality to parse WebIDL files, validate them, and extract information about typedefs, enums, and structs.</p> <p>It also handles polymorphism and adds comments to the parsed data.</p> <p>Functions:</p> <ul> <li> <code>parse_idl</code>             \u2013              <p>Parse the given WebIDL file.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>type_transformer</code>           \u2013            <p>Mapping of WebIDL types to internal representations.</p> </li> </ul>"},{"location":"reference/poly_scribe_code_gen/parse_idl/#poly_scribe_code_gen.parse_idl.type_transformer","title":"type_transformer  <code>module-attribute</code>","text":"<pre><code>type_transformer = {\n    \"boolean\": \"bool\",\n    \"byte\": \"char\",\n    \"ByteString\": \"string\",\n}\n</code></pre> <p>Mapping of WebIDL types to internal representations.</p>"},{"location":"reference/poly_scribe_code_gen/parse_idl/#poly_scribe_code_gen.parse_idl.parse_idl","title":"parse_idl","text":"<pre><code>parse_idl(idl_file: Path) -&gt; ParsedIDL\n</code></pre> <p>Parse the given WebIDL file.</p> <p>This function reads a WebIDL file, validates its content, and extracts typedefs, enums, structs, and inheritance data. It also handles polymorphism and adds comments to the parsed data. It returns a dictionary containing the parsed IDL data.</p> <p>Parameters:</p> <ul> <li> <code>idl_file</code>               (<code>Path</code>)           \u2013            <p>Path to the WebIDL file to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ParsedIDL</code>           \u2013            <p>A dictionary containing parsed IDL data, including typedefs, enums, structs, and inheritance data.</p> </li> </ul>"},{"location":"reference/poly_scribe_code_gen/py_gen/","title":"poly_scribe_code_gen.py_gen","text":""},{"location":"reference/poly_scribe_code_gen/py_gen/#poly_scribe_code_gen.py_gen","title":"py_gen","text":"<p>Generate Python code from parsed IDL data.</p> <p>This module provides functions to generate a Python package and Python files from parsed IDL data. It uses Jinja2 templates to render the code and formats it with black and isort.</p> <p>Functions:</p> <ul> <li> <code>generate_python</code>             \u2013              <p>Generate a Python file from the parsed IDL data.</p> </li> <li> <code>generate_python_package</code>             \u2013              <p>Generate a Python package from the parsed IDL data.</p> </li> </ul>"},{"location":"reference/poly_scribe_code_gen/py_gen/#poly_scribe_code_gen.py_gen.generate_python","title":"generate_python","text":"<pre><code>generate_python(\n    parsed_idl: ParsedIDL,\n    additional_data: AdditionalData,\n    out_file: Path,\n) -&gt; None\n</code></pre> <p>Generate a Python file from the parsed IDL data.</p> <p>Based on the parsed IDL data a pydantic model is generated. The generated file will be formatted with black and isort.</p> <p>Enumerations are generated as Enum classes. Any typedefs are generated as type aliases.</p> <p>In addition to the classes that hold the data, two functions are generated: <code>load</code> and <code>save</code>, which can be used to load and save the data from and to a file. These functions will, depending on the type of file store the data in different formats. The following formats are supported:</p> <ul> <li>JSON</li> <li>YAML</li> <li>CBOR</li> </ul> <p>Parameters:</p> <ul> <li> <code>parsed_idl</code>               (<code>ParsedIDL</code>)           \u2013            <p>The parsed IDL data.</p> </li> <li> <code>additional_data</code>               (<code>AdditionalData</code>)           \u2013            <p>Additional data for the package.</p> </li> <li> <code>out_file</code>               (<code>Path</code>)           \u2013            <p>The output file for the generated Python code.</p> </li> </ul>"},{"location":"reference/poly_scribe_code_gen/py_gen/#poly_scribe_code_gen.py_gen.generate_python_package","title":"generate_python_package","text":"<pre><code>generate_python_package(\n    parsed_idl: ParsedIDL,\n    additional_data: AdditionalData,\n    out_dir: Path,\n) -&gt; None\n</code></pre> <p>Generate a Python package from the parsed IDL data.</p> <p>The package will be created in the specified output directory. It will contain a source directory with the package name and an <code>__init__.py</code> file. Furthermore, a <code>pyproject.toml</code> file will be generated in the output directory. The package name is taken from the additional data. Other metadata can be set in the additional data as well.</p> <p>For more details on the generated python file, see the documentation of <code>generate_python</code>.</p> <p>Parameters:</p> <ul> <li> <code>parsed_idl</code>               (<code>ParsedIDL</code>)           \u2013            <p>The parsed IDL data.</p> </li> <li> <code>additional_data</code>               (<code>AdditionalData</code>)           \u2013            <p>Additional data for the package.</p> </li> <li> <code>out_dir</code>               (<code>Path</code>)           \u2013            <p>The output directory for the package.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the output directory is not a directory or if the package name is not set.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the package name is not set in the additional data.</p> </li> </ul>"}]}